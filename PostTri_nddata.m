function NODE = PostTri_nddata(CELL,node,N_I_N,N_I,N_H,N_L,X,Y,X1,X2,Y1,Y2,dx,dy)
% NODE = PostTri_nddata(CELL,M,node,N,N_I_N,N_I,N_H,N_L,X,Y,X1,X2,Y1,Y2,dx,dy) generate the node data structure
% and fill it with basic geometrical information for general mesh generated
% by Triangle
% CELL is the CELL data structure.
% node is the RAW node data structure that as the same format as the one
%       generated by Triangle, but been modified in previous steps.
% N_I_N is the number of immersed boundary nodes
% N_I is the total number of interior nodes
% N_H is the number of nodes on the height edge
% N_L is the number of nodes on the length edge
% X and Y is vector that stores the x and y coordinates of all nodes
% X1, X2, Y1 and Y2 are bounds of mesh domain
% dx is the node spacing on the horizontal outer rectangular boundaries.
% dy is the node spacing on the vertical outer rectangular boundaries.

%%%%%%%%%%%%%Structure of each element ND in NODE
%%%%%%%%%%% ND{1}~ND{11} are filled in the current function, where ND{8}~ND{11} for
% corner nodes are filled in bc.m since their values depends on the acutal
% type of boundary condition. In addition, the real more detailed value in
% ND{2} is modified later in bc.m since the ID is BC-dependent.

% ND{1}  The order number of current node, succeed from X and Y
% ND{2}  The identifier of boundary node, 1---On boundary; 0---Interior; -1---Immersed boundary
% ND{3}  Column vector of coordinate of current node

% ND{4}  The total number of triangles connected to current node
% ND{5}  The vector of order number of each connected triangle
% ND{6}  The vector of distance from the centroid each connected triangle
% ND{7}  The sum of reverse distance to each star triangle

% ND{8}  --- The total number of triangles connected to current boundary
% node that could be periodic (Empty for interior nodes)
% ND{9}  --- The vector of order number of each connected triangle for
% periodic boundary node (Empty for interior nodes)
% ND{10} --- The vector of distance from the centroid of each connected
% triangle to periodic boundary node (Empty for interior nodes)
% ND{11} --- The sum of reverse distance from each star triangle to
% periodic boundary node (Empty for interior nodes)

%%%%%%%%%% ND{12}~ND{15} are filled in later step when face data strucure is available
% ND{12}  The total number of faces connected to current node
% ND{13}  The vector of order number of each connected face
%%%%% Nodal star structure for boundary nodes that is potentially periodic %%%%%
% ND{14}  --- The total number of faces connected to current periodic node(Empty for interior nodes or under the third scenario for corner nodes in ND{16})
% ND{15}  --- The vector of order number of each connected face for periodic  boundary node (Empty for interior nodes or under the third scenario for corner nodes in ND{16})

%%%%%%%%%% ND{16} and ND{17} are empty for general mesh,ND{18} is filled in function stencil.m in the solver
%%%%%%%%%%%%%% Boundary normal stencil for IRT mesh ONLY %%%%%%%%%%%%%%
% ND{16} --- The column vector of order # of the stencil for plat boundaries(Empty for interior nodes)
% [Exterior periodic node #;On-boundary periodic node #;Interior neighbor node #; Interior interior neighbor node #;..]
% ND{17} --- The column vector of order # of the stencil for corner nodes along the diagonal direction (Empty for non-corner nodes).
% [near node #; further node #;..].
% ND{18} --- The clockwise upstream and downstream boundary neighbor node of current boundary node.
% A column vector with first row for upstream node and second row the downstream node(Empty for interior nodes)

%%%%%%%%%% ND{19}~ND{20} are filled in function bc.m in the solver
% ND{19} --- The vector of upwind and bounce-back pdf order # of current node on boundary for V1
% ND{20} --- The vector of upwind and bounce-back pdf order # of current node on boundary for V2

%%%%%%%%%% ND{21} is filled in function macro_bc.m in the solver
% ND{21} --- Dirichlet boundary conditions [density;x velocity;y velocity;temperature]

M=length(CELL);
N=length(node);


P=CELL{1};
e=ceil(10*sqrt(M*P{6})); %%%% Calculate the reference size

%% Fill ND{1}, ND{2} and ND{3}
%%% Create the node data structure
K=25;
NODE=cell(K,1);
NODE={NODE,NODE};
for l=1:N
    ND=cell(K,1);
    nd=node(l,:);
    
    ND{1,1}=l;
    ND{2,1}=nd(1,4);
    ND{3,1}=[nd(1,2);nd(1,3)];
    
    NODE{l}=ND;
end

%% Fill ND{4}~ND{7}
% Find the node star cell structure info
N_cell_star=zeros(1,N);
Order_cell_star=cell(1,N);
Boundary_ID=cell(1,N);
for l=1:N
    Order_cell_star{l}=0;
    Boundary_ID{l}=0;
end
for r=1:M
    P=CELL{r};
    for g=1:3
        %%% Order number vector of cells
        N_cell_star(P{6+g})=N_cell_star(P{6+g})+1;
        Order_vector=Order_cell_star{P{6+g}};
        Order_vector(1,end+1)=P{1};
        Order_cell_star{P{6+g}}=Order_vector;
        %%% Boundary ID
        B_ID=Boundary_ID{P{6+g}};
        B_ID(end+1)=P{9+g};
        Boundary_ID{P{6+g}}=B_ID;
    end
    
end
for l=1:N
    %%% Order number vector of cells
    Order_vector=Order_cell_star{l};
    Order_vector=Order_vector(1,2:end); % Eliminate the first 0 element
    Order_cell_star{l}=Order_vector;
    %%% Boundary ID
    B_ID=Boundary_ID{l};
    B_ID=B_ID(2:end); % Eliminate the first 0 element
    B_ID=unique(B_ID);
    if length(B_ID)~=1
        error('The same node has multiple boundary identifiers!');
    end
    Boundary_ID{l}=B_ID;
end
% Fill the star cell structure info into NODE
for l=1:N
    ND=NODE{l};
    
    a=N_cell_star(l);
    NCD=Order_cell_star{l};
    DC=zeros(1,a);
    for s=1:a
        P=CELL{NCD(s)};
        DC(1,s)=dis(ND{3},P{5});
    end
    ND{4,1}=a;
    ND{5,1}=NCD(1:a);
    ND{6,1}=DC(1,1:a);
    if ND{4}~=length(ND{5}) || ND{4}~=length(ND{6})
        error('The length of vector of order # of connected cell is wrong!');
    end
    D_sum=0;
    for g=1:ND{4,1};
        D_sum=D_sum+1/DC(1,g);
    end
    ND{7,1}=D_sum;
    NODE{l}=ND;
end

%% Checking data from ND{1} to ND{7}
for l=1:N
    ND=NODE{l};
    %% Check ND{2}
    if Boundary_ID{l}~=ND{2}
        error(['Node ', num2str(l), ' has false boundary identifier!']);
    end
    %% Check ND{3}
    if single(e+dis([X(l);Y(l)],ND{3}))~=single(e)
        error(['Node ', num2str(l), ' has false coordinate!']);
    end
    
    %% Find star nodes
    a=ND{4};
    ncd=ND{5};
    vertices=zeros(a,3);
    for i=1:a
        P=CELL{ncd(i)};
        vertices(i,1)=P{7};
        vertices(i,2)=P{8};
        vertices(i,3)=P{9};
    end
    vertx_uniq=ND{1}; % All nodes shared by all stat cells, including the center node
    for i=1:a
        vertx_uniq=union(vertx_uniq,vertices(i,:));
    end
    vertx_star=setxor(ND{1},vertx_uniq); % All star nodes
    % Check
    if (length(vertx_uniq)-length(vertx_star))~=1
        error('The star nodes have false info!');
    end
    
    %% Check ND{4} and ND{5}, if they are correct, ND{6} and ND{7} are most likely correct as well
    if ND{2}==1
        if (length(vertx_star)-a)~=1
            error('The star nodes have false info!');
        end
        for i=1:length(vertx_star)
            nd_star=NODE{vertx_star(i)};
            ncd_star=nd_star{5};
            if nd_star{2}==1 % Both the center node and star node are on outer boundary
                mid_point=(ND{3}+nd_star{3})/2;
                if (mid_point(1,1)>X1 && mid_point(1,1)<X2) && (mid_point(2,1)>Y1 && mid_point(2,1)<Y2) % the face connecting two nodes is interior face
                    if length(intersect(ncd_star,ND{5}))~=2 % two common cell
                        error('The star cells of boundary center node and interior star node should have only two common cell, since the face connecting two nodes is interior face!');
                    end
                else % the face connecting two nodes is boundary face
                    if length(intersect(ncd_star,ND{5}))~=1 % one common cell
                        error(['The star cells of boundary center node ',num2str(ND{1}), ' and boundary star node ', num2str(nd_star{1}), ' should have only one common cell, since the face connecting two nodes is boundary face!']);
                    end
                end
            elseif nd_star{2}==0 % The center is on outer boundary, the star node is interior
                if length(intersect(ncd_star,ND{5}))~=2 % two common cell
                    error('The star cells of boundary center node and interior star node should have only two common cell!');
                end
            elseif nd_star{2}==-1 % The center is on outer boundary, the star node is on inner boundary
                if length(intersect(ncd_star,ND{5}))~=2 % two common cell
                    error('The star cells of boundary center node and interior star node should have only two common cell!');
                end
                disp('Check mesh. The mesh between inner and outer boundaries should be refined!');
            else
                error('Wrong region identifier!');
            end
        end
    elseif ND{2}==0
        if (length(vertx_star)-a)~=0
            error('The star nodes have false info!');
        end
        for i=1:length(vertx_star)
            nd_star=NODE{vertx_star(i)};
            ncd_star=nd_star{5};
            if length(intersect(ncd_star,ND{5}))~=2 % two common cell
                error('The star cells of interio center node and star node should have only two common cell!');
            end
        end
    elseif ND{2}==-1
        if (length(vertx_star)-a)~=1
            error('The star nodes have false info!');
        end
        for i=1:length(vertx_star)
            nd_star=NODE{vertx_star(i)};
            ncd_star=nd_star{5};
            if nd_star{2}==1 % The center node is on inner boundary, the star node are on outer boundary
                if length(intersect(ncd_star,ND{5}))~=2 % two common cell
                    error('The star cells of inner boundary center node and outer boundary star node should have only two common cell!');
                end
                disp('Check mesh. The mesh between inner and outer boundaries should be refined!');
            elseif nd_star{2}==0 % The center is on inner boundary, the star node is interior
                if length(intersect(ncd_star,ND{5}))~=2 % two common cell
                    error('The star cells of boundary center node and interior star node should have only two common cell!');
                end
            elseif nd_star{2}==-1 % The center is on inner boundary, the star node is inner boundary
                if length(intersect(ncd_star,ND{5}))~=1 % two common cell
                    error('The star cells of inner boundary center node and inner boundary star node should have only one common cell!');
                end
            else
                error('Wrong region identifier!');
            end
        end
    else
        error('Wrong region identifier!');
    end
end

%% %%%%%% Find the periodic star structure of the nodes on boudaries in order to apply
% %%%%%% periodic boundary conditions
% %%%%% For any mesh as long as boundary nodes are lined up
% % ND{8}  --- The total number of triangles connected to current periodic node
% % ND{9}  --- The vector of order number of each connected triangle for
% % periodic boundary node (Empty for interior nodes)
% % ND{10} --- The vector of distance from the centroid of each connected
% % triangle to periodic boundary node (Empty for interior nodes)
% % ND{11} --- The sum of reverse distance from each star triangle to
% % periodic boundary node (Empty for interior nodes)
% &&&&&&&&&& ND{8}~ND{11} for corner nodes are filled in bc.m
for l=1:N
    if l<=N_I
        ; % Empty for interior nodes and inner boundary nodes
    elseif l==N_I+N_L-1 || l==N_I+N_L-1+N_H-1 || l==N_I+N_L-1+N_H-2+N_L || l==N % Give a temperay value,to be updated in bc.m
        % Each of corner node is fully periodic, both periodic in x and y
        % directions
        NP1=NODE{N_I+N_L-1}; % Top-Right
        NP2=NODE{N_I+N_L-1+N_H-1}; % Bottom-Right
        NP3=NODE{N_I+N_L-1+N_H-2+N_L}; % Bottom-Left
        NP4=NODE{N}; % Top-Left
        ND=NODE{l};
        %%%% Total number of connected cells
        ND{8,1}=NP1{4,1}+NP2{4,1}+NP3{4,1}+NP4{4,1};
        %%%% Vector of order # of connected cells
        NC=[NP1{5,1},NP2{5,1},NP3{5,1},NP4{5,1}];
        ND{9,1}=NC;
        if ND{8,1}~=length(ND{9,1})
            error('The length of vector of order # of connected cell is wrong!');
        end
        NDC=[NP1{6,1},NP2{6,1},NP3{6,1},NP4{6,1}];
        ND{10,1}=NDC;
        if ND{8,1}~=length(ND{10,1})
            error('The length of vector of distances of connected cell is wrong!');
        end
        D_sum=0;
        for g=1:ND{8,1};
            D_sum=D_sum+1/NDC(1,g);
        end
        ND{11,1}=D_sum;
        %%%% load back to NODE
        NODE{l}=ND;
    else
        ND=NODE{l};
        C_ND=ND{3};
        %%%%% Find the mirror node on the periodic boundary
        if C_ND(1,1)==X1
            X_target=X2;
            Y_target=C_ND(2,1);
        elseif C_ND(1,1)==X2
            X_target=X1;
            Y_target=C_ND(2,1);
        elseif C_ND(2,1)==Y1
            X_target=C_ND(1,1);
            Y_target=Y2;
        elseif C_ND(2,1)==Y2
            X_target=C_ND(1,1);
            Y_target=Y1;
        else
            error('The current node is not on the outer flat boundary (except for the corner nodes) !')
        end
        for t=1:N
            if single(e+X(t))==single(e+X_target) && single(e+Y(t))==single(e+Y_target)
                NP=NODE{t};
                break;
            end
        end
        if t==N
            error('mirror node on periodic boundary is not found, please check the spacing on boundry, dx=dy!');
        end
        %%%% Total number of connected cells
        ND{8,1}=ND{4,1}+NP{4,1};
        %%%% Vector of order # of connected cells
        NC=ND{5,1};
        L=length(NP{5,1});
        NC(1,end+1:end+L)=NP{5,1};
        ND{9,1}=NC;
        if ND{8,1}~=length(ND{9,1})
            error('The length of vector of order # of connected cell is wrong!');
        end
        %%%% Vector of distance
        NDC=ND{6,1};
        L=length(NP{6,1});
        NDC(1,end+1:end+L)=NP{6,1};
        ND{10,1}=NDC;
        if ND{8,1}~=length(ND{10,1})
            error('The length of vector of distance is wrong!');
        end
        %%%% Sum of reverse distance
        D_sum=0;
        for g=1:ND{8,1};
            D_sum=D_sum+1/NDC(g);
        end;
        ND{11,1}=D_sum;
        %%%% load back to NODE
        NODE{l}=ND;
    end
end