function [node,ele,neigh]=PostTri_meshq_ndmv(ele,node,neigh)
% function [node,ele]=PostTri_meshq_ndmv(ele,node,neigh) improves the mesh
% quality by just moving the nodes to repeatedly improved the localized mesh
% with the worst quality.
% ele---The element file just generated by Triangle
% node---The node file
% neigh---The neighbor file
%% Plan A, which is not working very well. The algorithm is to find the worst cell and improve
% M=length(ele(:,1));
% N=length(node(:,1));
% Res=20; % Step size refinement level for node moving
% AR_max=1.75; % Improvement stop criteria for Aspect Ratio
% SK_max=0.41; % Improvement stop criteria for Skewness
% %% Calculate the Aspect Ratio, angles and skewness of each triangle
% Theta_e=60; % reference angle for triangle
% Tri_angle=zeros(M,5);
% for r=1:M
%     T=ele(r,:);
%     nd_a=T(1,2);
%     nd_b=T(1,3);
%     nd_c=T(1,4);
%     C_a=node(nd_a,2:3)';
%     C_b=node(nd_b,2:3)';
%     C_c=node(nd_c,2:3)';
%     L_a=dis(C_a,C_b);
%     L_b=dis(C_b,C_c);
%     L_c=dis(C_c,C_a);
%     L_max=max(L_a,max(L_b,L_c));
%     L_min=min(L_a,min(L_b,L_c));
%     % Aspect Ratio
%     Tri_angle(r,1)=L_max/L_min;
%     % Angles
%     for k=1:3
%         if k==1
%             u=C_b-C_a;
%             v=C_c-C_a;
%         elseif k==2
%             u=C_c-C_b;
%             v=C_a-C_b;
%         else
%             u=C_a-C_c;
%             v=C_b-C_c;
%         end
%         Tri_angle(r,1+k)=angle(u,v);
%     end
%     if single(Tri_angle(r,2)+Tri_angle(r,3)+Tri_angle(r,4))~=single(180)
%         error('The sum of three angles is not 180 degrees!');
%     end
%     % Skewness
%     Theta_max=max(Tri_angle(r,2),max(Tri_angle(r,3),Tri_angle(r,4)));
%     Theta_min=min(Tri_angle(r,2),min(Tri_angle(r,3),Tri_angle(r,4)));
%     Tri_angle(r,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
% end
% %% Construct the node star structure for each node
% Star=cell(1,N);
% for r=1:N
%     P=Star{r};
%     [n,star]=PostTri_findstar(r,ele);
%     P{1,1}=n; % number of triangles in the current star structure
%     P{2,1}=star; % vector of those triangle order numbers
%     q=0;
%     poly_star=0;
%     for l=1:n
%         T=ele(star(l),2:4);
%         for w=1:3
%             if T(w)~=r
%                 if l==1 && (w==1 || w==2)
%                     q=q+1;
%                     poly_star(q)=T(w);
%                 else
%                     found_dup_nd=0;
%                     for x=1:q
%                         if T(w)==poly_star(x)
%                             found_dup_nd=1;
%                         end
%                     end
%                     if found_dup_nd
%                         ;
%                     else
%                         q=q+1;
%                         poly_star(q)=T(w);
%                     end
%                 end
%             end
%         end
%     end
%     P{3,1}=q; % The number of saterlite nodes in the current star structure
%     P{4,1}=poly_star; % The vector of saterlite node order numbers in the current star structure
%     poly_center=[0,0];
%     for s=1:P{3,1}
%         poly_center=poly_center+node(poly_star(s),2:3);
%     end
%     poly_center=poly_center/P{3,1};
%     P{5,1}=poly_center; % The centroid of the polygon constructed by the outer boundaries of the star structure
%     AR=zeros(1,P{1,1});
%     for s=1:P{1,1}
%         AR(s)=Tri_angle(star(s),1);
%     end
%     P{6,1}=max(AR); % The biggest AR among all star triangles
% 
%     SK=zeros(1,P{1,1});
%     for s=1:P{1,1}
%         SK(s)=Tri_angle(star(s),5);
%     end
%     P{7,1}=max(SK); % the biggest Skewness among all star triangles
%     
%     Star{r}=P;
% end
% %% Plot mesh quality in Aspect Ratio and Skewness
% edge1_x=zeros(M,2);
% edge2_x=zeros(M,2);
% edge3_x=zeros(M,2);
% edge1_y=zeros(M,2);
% edge2_y=zeros(M,2);
% edge3_y=zeros(M,2);
% for r=1:M
%     nd1=ele(r,2);
%     nd2=ele(r,3);
%     nd3=ele(r,4);
%     edge1_x(r,:)=[node(nd1,2),node(nd2,2)];
%     edge2_x(r,:)=[node(nd2,2),node(nd3,2)];
%     edge3_x(r,:)=[node(nd3,2),node(nd1,2)];
%     edge1_y(r,:)=[node(nd1,3),node(nd2,3)];
%     edge2_y(r,:)=[node(nd2,3),node(nd3,3)];
%     edge3_y(r,:)=[node(nd3,3),node(nd1,3)];
% end
% figure(1);
% for r=1:M
%     plot(edge1_x(r,:),edge1_y(r,:));
%     hold on
%     plot(edge2_x(r,:),edge2_y(r,:));
%     hold on
%     plot(edge3_x(r,:),edge3_y(r,:));
%     hold on
% end
% hold on
% for r=1:N
%     P=Star{r};
%     cent=P{5};
%     plot(cent(1),cent(2), 'Marker', 'o','Markersize',3, 'MarkerFaceColor', 'black','MarkerEdgeColor', 'black');
%     hold on
% end
% axis equal tight
% X=node(:,2);
% Y=node(:,3);
% X1=min(X);
% X2=max(X);
% Y1=min(Y);
% Y2=max(Y);
% figure(1);
% xlin=linspace(X1,X2,100);
% ylin=linspace(Y1,Y2,100);
% [Xx,Yy]=meshgrid(xlin,ylin);
% Ar_max=zeros(N,1);
% Sk_max=zeros(N,1);
% for r=1:N
%     P=Star{r};
%     Ar_max(r)=P{6};
%     Sk_max(r)=P{7};
% end
% % figure(2);
% % Z=griddata(X,Y,Ar_max,Xx,Yy);
% % contourf(Xx,Yy,Z,100);
% % axis equal tight;
% % 
% % figure(3);
% % Z=griddata(X,Y,Sk_max,Xx,Yy);
% % contourf(Xx,Yy,Z,100);
% % axis equal tight;
% %% Improving the mesh quality
% Ar_max_global=max(Ar_max);
% Sk_max_global=max(Sk_max);
% if Ar_max_global>AR_max || Sk_max_global>SK_max
%     found_bad_triangle=1;
% end
% % Loop for quality improvement
% nd_move=1;
% counter=zeros(N,1); % To counter how many times each node is selected.
% a=0;
% while found_bad_triangle
%     a=a+1; % Counting how many times the outer while loop is triggered
%     % Find the specific node that has the bad triangle in its star
%     % structure
%     backup_plan=0;
%     for r=1:N
%         if (single(Ar_max(r))==single(Ar_max_global) || single(Sk_max(r))==single(Sk_max_global)) && node(r,4)==0; % the found node is interior node, good to move
%             break;
%         end
%     end
%     if r==N
%         error('The node for moving is not found');
%     elseif r==nd_move
%         counter(r,1)=counter(r,1)+1;
%         % if the same node is selected, move the saterlite node that has
%         % the longest distence to the centroid of the polygon belonging to
%         % that node
%         backup_plan=1;
%         P=Star{r};
%         Sat=P{4};
% %         dis_sat=0;
% %         for g=1:P{3}
% %             Q=Star{Sat(g)};
% %             dis_sat(g)=dis(node(Sat(g),2:3)',Q{5}');
% %         end
% %         dis_sat_max=max(dis_sat);
% %         for g=1:P{3}
% %             if dis_sat(g)==dis_sat_max
% %                 break;
% %             end
% %         end
%         % Pick the saterlite node that is not on boundary
%         m=0;
%         for g=1:P{3}
%             if node(Sat(g),4)==0
%                 m=m+1;
%                 Sat_interior(m)=Sat(g);
%             end
%         end
%         % Choose another node to move
% %         if node(Sat(g),4)==0
% %             r=Sat(g);
% %         else
%             x=round(rand(1)*m);
%             while x==0
%                 x=round(rand(1)*m);
%             end
%             r=Sat_interior(x);
% %         end
%         counter(r,1)=counter(r,1)+1;
%         if counter(r,1)>200
%             WARNING=['Node number ', num2str(r), ' has been revoked 200 times!']
%             break;
%         end
%     end
%     % Dertermine which triangle connected to the found node has the largest
%     % Aspect Ratio or Skewness
% %     P=Star{r};
% %     n=P{1};
% %     Tri_star=P{2};
% %     for s=1:n
% %         AR_Tri_star=Tri_angle(Tri_star(s),1);
% %         SK_Tri_star=Tri_angle(Tri_star(s),5);
% %         if single(AR_Tri_star)==single(Ar_max_global) || single(SK_Tri_star)==single(Sk_max_global)
% %             break;
% %         end
% %     end
% %     if s==n
% %         if single(AR_Tri_star)~=single(Ar_max_global) && single(SK_Tri_star)~=single(Sk_max_global)
% %             error('The triangle in the star structure with the largest aspect ratio or skewness is not found!');
% %         end
% %     end
%     % Determine the moving direction and moving step size
%     nd_move=r;
%     P=Star{nd_move};
%     move_start=node(nd_move,2:3);
%     move_end=P{5};
%     DIST=dis(move_start',move_end');
%     vec_move=(move_end-move_start)'/DIST;
%     h=DIST/10;
% %     % Determine which angle in the found triangle is connected to the found
% %     % node
% %     t=Tri_star(s);
% %     T=ele(t,:);
% %     if T(1,2)==r
% %         nd_move=r;
% %         nd_oppose_start=T(1,3);
% %         nd_oppose_end=T(1,4);
% %         Angle_move=Tri_angle(t,2);
% %         Angle_start=Tri_angle(t,3);
% %         Angle_end=Tri_angle(t,4);
% %     elseif T(1,3)==r
% %         nd_move=r;
% %         nd_oppose_start=T(1,4);
% %         nd_oppose_end=T(1,2);
% %         Angle_move=Tri_angle(t,3);
% %         Angle_start=Tri_angle(t,4);
% %         Angle_end=Tri_angle(t,2);
% %     elseif T(1,4)==r
% %         nd_move=r;
% %         nd_oppose_start=T(1,2);
% %         nd_oppose_end=T(1,3);
% %         Angle_move=Tri_angle(t,4);
% %         Angle_start=Tri_angle(t,2);
% %         Angle_end=Tri_angle(t,3);
% %     else
% %         error('The found triangle is not connected to the found node!');
% %     end
% %     % Determine whether the found angle is the greatest angle in the found triangle,
% %     % which will determine the moving direction and max moving distance
% %     if Angle_move<max(Tri_angle(t,2),max(Tri_angle(t,3),Tri_angle(t,4))) % The found angle is not the largest, moving direction is parallel to the oppsing edge
% %         if Angle_start>Angle_end
% %             vec_move=(node(nd_oppose_end,2:3)-node(nd_oppose_start,2:3))'/dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)');
% %             h=dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)')/Res;
% %         else
% %             vec_move=(node(nd_oppose_start,2:3)-node(nd_oppose_end,2:3))'/dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)');
% %             h=dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)')/Res;
% %         end
% %     else % The found angle is the largest, moving direction is normal to the oppsing edge
% %         n_x=-(node(nd_oppose_end,3)-node(nd_oppose_start,3))/dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)');
% %         n_y=(node(nd_oppose_end,2)-node(nd_oppose_start,2))/dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)');
% %         vec_move=[n_x;n_y];
% %         h=dis(node(nd_oppose_end,2:3)',node(nd_oppose_start,2:3)')/Res;
% %     end
%     % Move the node, use incremental method to determine the moving distance
%     % that can maximize the mesh quality
% %     node_temp=node;
% %     AR_star_max=AR_Tri_star;
% %     SK_star_max=SK_Tri_star;
% %     C_nd_move=node(nd_move,2:3)';
% %     C_nd_move_new=C_nd_move+vec_move*h;
% %     node_temp(nd_move,2:3)=C_nd_move_new';
% %     % calculate the Aspect Ratio and Skewness of all triangles affected by
% %     % the moving center node in the star structure
% %     Star_angle=zeros(n,5);
% %     for f=1:n
% %         T=ele(Tri_star(f),:);
% %         nd_a=T(1,2);
% %         nd_b=T(1,3);
% %         nd_c=T(1,4);
% %         C_a=node_temp(nd_a,2:3)';
% %         C_b=node_temp(nd_b,2:3)';
% %         C_c=node_temp(nd_c,2:3)';
% %         L_a=dis(C_a,C_b);
% %         L_b=dis(C_b,C_c);
% %         L_c=dis(C_c,C_a);
% %         L_max=max(L_a,max(L_b,L_c));
% %         L_min=min(L_a,min(L_b,L_c));
% %         % Aspect Ratio
% %         Star_angle(f,1)=L_max/L_min;
% %         % Angles
% %         for k=1:3
% %             if k==1
% %                 u=C_b-C_a;
% %                 v=C_c-C_a;
% %             elseif k==2
% %                 u=C_c-C_b;
% %                 v=C_a-C_b;
% %             else
% %                 u=C_a-C_c;
% %                 v=C_b-C_c;
% %             end
% %             Star_angle(f,1+k)=angle(u,v);
% %         end
% %         if single(Star_angle(f,2)+Star_angle(f,3)+Star_angle(f,4))~=single(180)
% %             error('The sum of three angles is not 180 degrees!');
% %         end
% %         % Skewness
% %         Theta_max=max(Star_angle(f,2),max(Star_angle(f,3),Star_angle(f,4)));
% %         Theta_min=min(Star_angle(f,2),min(Star_angle(f,3),Star_angle(f,4)));
% %         Star_angle(f,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
% %     end
% %     AR_star_max_new=max(Star_angle(:,1));
% %     SK_star_max_new=max(Star_angle(:,5));
% %     % Moving the node
% %     b=0;
% %     while AR_star_max_new<AR_star_max && SK_star_max_new<SK_star_max
% %         b=b+1;
% %         AR_star_max=AR_star_max_new;
% %         SK_star_max=SK_star_max_new;
% %         C_nd_move=C_nd_move_new;
% %         C_nd_move_new=C_nd_move+vec_move*h;
% %         node_temp(nd_move,2:3)=C_nd_move_new';
% %         
% %         Star_angle=zeros(n,5);
% %         for f=1:n
% %             T=ele(Tri_star(f),:);
% %             nd_a=T(1,2);
% %             nd_b=T(1,3);
% %             nd_c=T(1,4);
% %             C_a=node_temp(nd_a,2:3)';
% %             C_b=node_temp(nd_b,2:3)';
% %             C_c=node_temp(nd_c,2:3)';
% %             L_a=dis(C_a,C_b);
% %             L_b=dis(C_b,C_c);
% %             L_c=dis(C_c,C_a);
% %             L_max=max(L_a,max(L_b,L_c));
% %             L_min=min(L_a,min(L_b,L_c));
% %             % Aspect Ratio
% %             Star_angle(f,1)=L_max/L_min;
% %             % Angles
% %             for k=1:3
% %                 if k==1
% %                     u=C_b-C_a;
% %                     v=C_c-C_a;
% %                 elseif k==2
% %                     u=C_c-C_b;
% %                     v=C_a-C_b;
% %                 else
% %                     u=C_a-C_c;
% %                     v=C_b-C_c;
% %                 end
% %                 Star_angle(f,1+k)=angle(u,v);
% %             end
% %             if single(Star_angle(f,2)+Star_angle(f,3)+Star_angle(f,4))~=single(180)
% %                 error('The sum of three angles is not 180 degrees!');
% %             end
% %             % Skewness
% %             Theta_max=max(Star_angle(f,2),max(Star_angle(f,3),Star_angle(f,4)));
% %             Theta_min=min(Star_angle(f,2),min(Star_angle(f,3),Star_angle(f,4)));
% %             Star_angle(f,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
% %         end
% %         AR_star_max_new=max(Star_angle(:,1));
% %         SK_star_max_new=max(Star_angle(:,5));
% %     end
%     C_nd_move_final=move_end';
%     % C_nd_move_final=(C_nd_move+C_nd_move_new)/2;
%     % update node file
%     node(nd_move,2:3)=C_nd_move_final';
%     % update the Tri_angle variable
%     P=Star{nd_move};
%     n=P{1};
%     Tri_star=P{2};
%     for f=1:n
%         T=ele(Tri_star(f),:);
%         nd_a=T(1,2);
%         nd_b=T(1,3);
%         nd_c=T(1,4);
%         C_a=node(nd_a,2:3)';
%         C_b=node(nd_b,2:3)';
%         C_c=node(nd_c,2:3)';
%         L_a=dis(C_a,C_b);
%         L_b=dis(C_b,C_c);
%         L_c=dis(C_c,C_a);
%         L_max=max(L_a,max(L_b,L_c));
%         L_min=min(L_a,min(L_b,L_c));
%         % Aspect Ratio
%         Tri_angle(Tri_star(f),1)=L_max/L_min;
%         % Angles
%         for k=1:3
%             if k==1
%                 u=C_b-C_a;
%                 v=C_c-C_a;
%             elseif k==2
%                 u=C_c-C_b;
%                 v=C_a-C_b;
%             else
%                 u=C_a-C_c;
%                 v=C_b-C_c;
%             end
%             Tri_angle(Tri_star(f),1+k)=angle(u,v);
%         end
%         if single(Tri_angle(Tri_star(f),2)+Tri_angle(Tri_star(f),3)+Tri_angle(Tri_star(f),4))~=single(180)
%             error('The sum of three angles is not 180 degrees!');
%         end
%         % Skewness
%         Theta_max=max(Tri_angle(Tri_star(f),2),max(Tri_angle(Tri_star(f),3),Tri_angle(Tri_star(f),4)));
%         Theta_min=min(Tri_angle(Tri_star(f),2),min(Tri_angle(Tri_star(f),3),Tri_angle(Tri_star(f),4)));
%         Tri_angle(Tri_star(f),5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
%     end
%     % Update Star
%     for r=1:N
%         P=Star{r};
%         star=P{2,1};
%         
%         poly_star=P{4,1};
%         poly_center=[0,0];
%         for s=1:P{3,1}
%             poly_center=poly_center+node(poly_star(s),2:3);
%         end
%         poly_center=poly_center/P{3,1};
%         P{5,1}=poly_center; % The centroid of the polygon constructed by the outer boundaries of the star structure
%         AR=zeros(1,P{1,1});
%         for s=1:P{1,1}
%             AR(s)=Tri_angle(star(s),1);
%         end
%         P{6,1}=max(AR); % The biggest AR among all star triangles
%         
%         SK=zeros(1,P{1,1});
%         for s=1:P{1,1}
%             SK(s)=Tri_angle(star(s),5);
%         end
%         P{7,1}=max(SK); % the biggest Skewness among all star triangles
%         
%         Star{r}=P;
%     end
%     % Update global threshold
%     Ar_max=zeros(N,1);
%     Sk_max=zeros(N,1);
%     for f=1:N
%         P=Star{f};
%         Ar_max(f)=P{6};
%         Sk_max(f)=P{7};
%     end
%     Ar_max_global=max(Ar_max);
%     Sk_max_global=max(Sk_max);
%     if Ar_max_global>AR_max || Sk_max_global>SK_max
%         found_bad_triangle=1;
%     else
%         found_bad_triangle=0;
%     end
% end
% %% Plot the final mesh
% figure(1);
% edge1_x=zeros(M,2);
% edge2_x=zeros(M,2);
% edge3_x=zeros(M,2);
% edge1_y=zeros(M,2);
% edge2_y=zeros(M,2);
% edge3_y=zeros(M,2);
% for r=1:M
%     nd1=ele(r,2);
%     nd2=ele(r,3);
%     nd3=ele(r,4);
%     edge1_x(r,:)=[node(nd1,2),node(nd2,2)];
%     edge2_x(r,:)=[node(nd2,2),node(nd3,2)];
%     edge3_x(r,:)=[node(nd3,2),node(nd1,2)];
%     edge1_y(r,:)=[node(nd1,3),node(nd2,3)];
%     edge2_y(r,:)=[node(nd2,3),node(nd3,3)];
%     edge3_y(r,:)=[node(nd3,3),node(nd1,3)];
% end
% for r=1:M
%     plot(edge1_x(r,:),edge1_y(r,:),'red');
%     hold on
%     plot(edge2_x(r,:),edge2_y(r,:),'red');
%     hold on
%     plot(edge3_x(r,:),edge3_y(r,:),'red');
%     hold on
% end
%% Plan A end


%% Plan B, which is working better. The algorithm is to move each node to its tentative polygon centroid,
% which will globally improve the mesh quality
M=length(ele(:,1));
N=length(node(:,1));
%% Kill 4-Tri and 7-Tri(for stencil) structure
% Construct the node star structure for each node
Star=cell(1,N);
for r=1:N
    P=Star{r};
    [n,star]=PostTri_findstar(r,ele);
    P{1,1}=n; % number of triangles in the current star structure
    P{2,1}=star; % vector of those triangle order numbers
    q=0;
    poly_star=0;
    for l=1:n
        T=ele(star(l),2:4);
        for w=1:3
            if T(w)~=r
                if l==1 && (w==1 || w==2)
                    q=q+1;
                    poly_star(q)=T(w);
                else
                    found_dup_nd=0;
                    for x=1:q
                        if T(w)==poly_star(x)
                            found_dup_nd=1;
                        end
                    end
                    if found_dup_nd
                        ;
                    else
                        q=q+1;
                        poly_star(q)=T(w);
                    end
                end
            end
        end
    end
    P{3,1}=q; % The number of saterlite nodes in the current star structure
    P{4,1}=poly_star; % The vector of saterlite node order numbers in the current star structure

    P{5,1}=0; % The centroid of the polygon constructed by the outer boundaries of the star structure

    P{6,1}=0; % The biggest AR among all star triangles

    P{7,1}=0; % the biggest Skewness among all star triangles
    
    Star{r}=P;
end
% kill all 4-triangle structure by swapping
[ele,neigh,Star]=PostTri_4Tri_killer(ele,node,neigh,Star);
% kill all 7-triangle structure by swapping into 6-Tri structure
% [ele,neigh,Star]=PostTri_7Tri_killer(ele,node,neigh,Star);
%% plot after swap
% figure(1);
% edge1_x=zeros(M,2);
% edge2_x=zeros(M,2);
% edge3_x=zeros(M,2);
% edge1_y=zeros(M,2);
% edge2_y=zeros(M,2);
% edge3_y=zeros(M,2);
% for r=1:M
%     nd1=ele(r,2);
%     nd2=ele(r,3);
%     nd3=ele(r,4);
%     edge1_x(r,:)=[node(nd1,2),node(nd2,2)];
%     edge2_x(r,:)=[node(nd2,2),node(nd3,2)];
%     edge3_x(r,:)=[node(nd3,2),node(nd1,2)];
%     edge1_y(r,:)=[node(nd1,3),node(nd2,3)];
%     edge2_y(r,:)=[node(nd2,3),node(nd3,3)];
%     edge3_y(r,:)=[node(nd3,3),node(nd1,3)];
% end
% for r=1:M
%     plot(edge1_x(r,:),edge1_y(r,:),'black');
%     hold on
%     plot(edge2_x(r,:),edge2_y(r,:),'black');
%     hold on
%     plot(edge3_x(r,:),edge3_y(r,:),'black');
%     hold on
% end
% axis equal tight
%% Global parameters setup
AR_max=1.70; % Improvement stop criteria for Aspect Ratio
SK_max=0.35; % Improvement stop criteria for Skewness
%% Calculate the Aspect Ratio, angles and skewness of each triangle
Theta_e=60; % reference angle for triangle
Tri_angle=zeros(M,5);
for r=1:M
    T=ele(r,:);
    nd_a=T(1,2);
    nd_b=T(1,3);
    nd_c=T(1,4);
    C_a=node(nd_a,2:3)';
    C_b=node(nd_b,2:3)';
    C_c=node(nd_c,2:3)';
    L_a=dis(C_a,C_b);
    L_b=dis(C_b,C_c);
    L_c=dis(C_c,C_a);
    L_max=max(L_a,max(L_b,L_c));
    L_min=min(L_a,min(L_b,L_c));
    % Aspect Ratio
    Tri_angle(r,1)=L_max/L_min;
    % Angles
    for k=1:3
        if k==1
            u=C_b-C_a;
            v=C_c-C_a;
        elseif k==2
            u=C_c-C_b;
            v=C_a-C_b;
        else
            u=C_a-C_c;
            v=C_b-C_c;
        end
        Tri_angle(r,1+k)=angle(u,v);
    end
    if single(Tri_angle(r,2)+Tri_angle(r,3)+Tri_angle(r,4))~=single(180)
        Tri_angle(r,2)
        Tri_angle(r,3)
        Tri_angle(r,4)
        single(Tri_angle(r,2)+Tri_angle(r,3)+Tri_angle(r,4))
        error('The sum of three angles is not 180 degrees!');
    end
    % Skewness
    Theta_max=max(Tri_angle(r,2),max(Tri_angle(r,3),Tri_angle(r,4)));
    Theta_min=min(Tri_angle(r,2),min(Tri_angle(r,3),Tri_angle(r,4)));
    Tri_angle(r,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
end
%% Fill the information into the Star cell
for r=1:N
    P=Star{r};
    star=P{2,1};
    poly_star=P{4,1}; % The vector of saterlite node order numbers in the current star structure
    poly_center=[0,0];
    for s=1:P{3,1}
        poly_center=poly_center+node(poly_star(s),2:3);
    end
    poly_center=poly_center/P{3,1};
    P{5,1}=poly_center; % The centroid of the polygon constructed by the outer boundaries of the star structure
    AR=zeros(1,P{1,1});
    for s=1:P{1,1}
        AR(s)=Tri_angle(star(s),1);
    end
    P{6,1}=max(AR); % The biggest AR among all star triangles

    SK=zeros(1,P{1,1});
    for s=1:P{1,1}
        SK(s)=Tri_angle(star(s),5);
    end
    P{7,1}=max(SK); % the biggest Skewness among all star triangles
    
    Star{r}=P;
end
%% Plot mesh quality in Aspect Ratio and Skewness
% % edge1_x=zeros(M,2);
% % edge2_x=zeros(M,2);
% % edge3_x=zeros(M,2);
% % edge1_y=zeros(M,2);
% % edge2_y=zeros(M,2);
% % edge3_y=zeros(M,2);
% % for r=1:M
% %     nd1=ele(r,2);
% %     nd2=ele(r,3);
% %     nd3=ele(r,4);
% %     edge1_x(r,:)=[node(nd1,2),node(nd2,2)];
% %     edge2_x(r,:)=[node(nd2,2),node(nd3,2)];
% %     edge3_x(r,:)=[node(nd3,2),node(nd1,2)];
% %     edge1_y(r,:)=[node(nd1,3),node(nd2,3)];
% %     edge2_y(r,:)=[node(nd2,3),node(nd3,3)];
% %     edge3_y(r,:)=[node(nd3,3),node(nd1,3)];
% % end
% figure(1);
% hold on;
% % for r=1:M
% %     plot(edge1_x(r,:),edge1_y(r,:));
% %     hold on
% %     plot(edge2_x(r,:),edge2_y(r,:));
% %     hold on
% %     plot(edge3_x(r,:),edge3_y(r,:));
% %     hold on
% % end
% % hold on
% for r=1:N
%     P=Star{r};
%     cent=P{5};
%     plot(cent(1),cent(2), 'Marker', 'o','Markersize',3, 'MarkerFaceColor', 'black','MarkerEdgeColor', 'black');
%     hold on
% end

X=node(:,2);
Y=node(:,3);
X1=min(X);
X2=max(X);
Y1=min(Y);
Y2=max(Y);
xlin=linspace(X1,X2,100);
ylin=linspace(Y1,Y2,100);
[Xx,Yy]=meshgrid(xlin,ylin);
Ar_max=zeros(N,1);
Sk_max=zeros(N,1);
for r=1:N
    P=Star{r};
    Ar_max(r)=P{6};
    Sk_max(r)=P{7};
end
% figure(3);
% Z=griddata(X,Y,Ar_max,Xx,Yy);
% contourf(Xx,Yy,Z,100);
% axis equal tight;
% 
% figure(4);
% Z=griddata(X,Y,Sk_max,Xx,Yy);
% contourf(Xx,Yy,Z,100);
% axis equal tight;
%% Improving the mesh quality
Ar_max_global=max(Ar_max);
Sk_max_global=max(Sk_max);
if Ar_max_global>AR_max || Sk_max_global>SK_max
    found_bad_triangle=1;
end
% Loop for quality improvement
WAR=['Before movement, Ar_max_global=',num2str(Ar_max_global), ', ', 'Sk_max_global=', num2str(Sk_max_global), '.' ]
AR_avg_b4=norm(Tri_angle(:,1),1)/M
SK_avg_b4=norm(Tri_angle(:,5),1)/M
a=0;
Iter=7;
Fac=0;
Ratio=0.1;
while found_bad_triangle
    a=a+1;
    if a>Iter
        break;
    end
    node_temp=node;
    % Move
    for i=1:N
        P=Star{i};
        if dis(node_temp(i,2:3)',[1;1])>0.68 % This line is specifically to restrict the node-moving ONLY to the region that is out of the inner buffer region
            if (P{6}>AR_max*Fac || P{7}>SK_max*Fac) && node_temp(i,4)==0
                S=P{4};
                sat_nd_on_boundary=0;
                for s=1:P{3}
                    if node(S(s),4)~=0
                        sat_nd_on_boundary=1;
                        break;
                    end
                end
                if sat_nd_on_boundary % The interior node right next to the boundary nodes
                    dis_move=dis(P{5}',node_temp(i,2:3)');
                    vec_move=(P{5}-node_temp(i,2:3))/dis_move;
                    move_end=node_temp(i,2:3)+Ratio*dis_move*vec_move;
                    node_temp(i,2:3)=move_end;
                else % Other interior nodes
                    move_end=P{5};
                    node_temp(i,2:3)=move_end;
                end
            end
        end
    end
    % Update
    
    for r=1:M
        T=ele(r,:);
        nd_a=T(1,2);
        nd_b=T(1,3);
        nd_c=T(1,4);
        C_a=node_temp(nd_a,2:3)';
        C_b=node_temp(nd_b,2:3)';
        C_c=node_temp(nd_c,2:3)';
        L_a=dis(C_a,C_b);
        L_b=dis(C_b,C_c);
        L_c=dis(C_c,C_a);
        L_max=max(L_a,max(L_b,L_c));
        L_min=min(L_a,min(L_b,L_c));
        % Aspect Ratio
        Tri_angle(r,1)=L_max/L_min;
        % Angles
        for k=1:3
            if k==1
                u=C_b-C_a;
                v=C_c-C_a;
            elseif k==2
                u=C_c-C_b;
                v=C_a-C_b;
            else
                u=C_a-C_c;
                v=C_b-C_c;
            end
            Tri_angle(r,1+k)=angle(u,v);
        end
        if single(Tri_angle(r,2)+Tri_angle(r,3)+Tri_angle(r,4))~=single(180)
            error('The sum of three angles is not 180 degrees!');
        end
        % Skewness
        Theta_max=max(Tri_angle(r,2),max(Tri_angle(r,3),Tri_angle(r,4)));
        Theta_min=min(Tri_angle(r,2),min(Tri_angle(r,3),Tri_angle(r,4)));
        Tri_angle(r,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
    end
    
    for r=1:N
        P=Star{r};
        star=P{2,1};
        
        poly_star=P{4,1};
        poly_center=[0,0];
        for s=1:P{3,1}
            poly_center=poly_center+node_temp(poly_star(s),2:3);
        end
        poly_center=poly_center/P{3,1};
        P{5,1}=poly_center; % The centroid of the polygon constructed by the outer boundaries of the star structure
        AR=zeros(1,P{1,1});
        for s=1:P{1,1}
            AR(s)=Tri_angle(star(s),1);
        end
        P{6,1}=max(AR); % The biggest AR among all star triangles
        
        SK=zeros(1,P{1,1});
        for s=1:P{1,1}
            SK(s)=Tri_angle(star(s),5);
        end
        P{7,1}=max(SK); % the biggest Skewness among all star triangles
        
        Star{r}=P;
    end
    % Update global threshold
    Ar_max=zeros(N,1);
    Sk_max=zeros(N,1);
    for f=1:N
        P=Star{f};
        Ar_max(f)=P{6};
        Sk_max(f)=P{7};
    end
    Ar_max_global=max(Ar_max);
    Sk_max_global=max(Sk_max);
    if Ar_max_global>AR_max || Sk_max_global>SK_max
        found_bad_triangle=1;
    else
        found_bad_triangle=0;
    end
    
    node=node_temp;
end
WAR=['After movement, Ar_max_global=',num2str(Ar_max_global), ', ', 'Sk_max_global=', num2str(Sk_max_global), '.' ]
AR_avg_after=norm(Tri_angle(:,1),1)/M
SK_avg_after=norm(Tri_angle(:,5),1)/M
%% Plot the final mesh
% figure(2);
% edge1_x=zeros(M,2);
% edge2_x=zeros(M,2);
% edge3_x=zeros(M,2);
% edge1_y=zeros(M,2);
% edge2_y=zeros(M,2);
% edge3_y=zeros(M,2);
% for r=1:M
%     nd1=ele(r,2);
%     nd2=ele(r,3);
%     nd3=ele(r,4);
%     edge1_x(r,:)=[node(nd1,2),node(nd2,2)];
%     edge2_x(r,:)=[node(nd2,2),node(nd3,2)];
%     edge3_x(r,:)=[node(nd3,2),node(nd1,2)];
%     edge1_y(r,:)=[node(nd1,3),node(nd2,3)];
%     edge2_y(r,:)=[node(nd2,3),node(nd3,3)];
%     edge3_y(r,:)=[node(nd3,3),node(nd1,3)];
% end
% for r=1:M
%     plot(edge1_x(r,:),edge1_y(r,:),'black');
%     hold on
%     plot(edge2_x(r,:),edge2_y(r,:),'black');
%     hold on
%     plot(edge3_x(r,:),edge3_y(r,:),'black');
%     hold on
% end
% axis equal tight
% for r=1:N
%     plot(node(r,2),node(r,3), 'Marker', 'o','Markersize',3, 'MarkerFaceColor', 'black','MarkerEdgeColor', 'black');
%     hold on
% end
% % Display the node with worst triangle connected
% for r=1:N
%     if (single(Ar_max(r))==single(Ar_max_global) || single(Sk_max(r))==single(Sk_max_global)) && node(r,4)==0; % the found node is interior node, good to move
%         break;
%     end
% end
% figure(2);
% plot(node(r,2),node(r,3), 'Marker', 'o','Markersize',4, 'MarkerFaceColor', 'red','MarkerEdgeColor', 'red');
% hold on
% text(node(r,2),node(r,3), 'The node that connects the worst triangle', 'Color', 'r')
% hold on
% % Display all nodes shared by bad quality mesh
% bad_nd_counter=0;
% for s=1:N
%     if ((single(Ar_max(s))>=single(AR_max) || single(Sk_max(s))>=single(SK_max)) && node(s,4)==0) && (s~=r)
%         bad_nd_counter=bad_nd_counter+1;
%         bad_nd(bad_nd_counter)=s;
%     end
% end
% figure(2);
% for s=1:bad_nd_counter
%     plot(node(bad_nd(s),2),node(bad_nd(s),3), 'Marker', 'o','Markersize',4, 'MarkerFaceColor', 'y','MarkerEdgeColor', 'y');
%     text(node(bad_nd(s),2),node(bad_nd(s),3), 'The node that connects the bad triangle worst than the threshold', 'Color', 'y');
%     hold on
% end
%%%% Plan B ends %%%%

%% Plan C starts, always find the single triangle with worst AR or SK, move all its vertices that are not on boundary to improve the quality
%% Construct the node star structure for each node before killing 4-Tri structure
% M=length(ele(:,1));
% N=length(node(:,1));
% Star=cell(1,N);
% for r=1:N
%     P=Star{r};
%     [n,star]=PostTri_findstar(r,ele);
%     P{1,1}=n; % number of triangles in the current star structure
%     P{2,1}=star; % vector of those triangle order numbers
%     q=0;
%     poly_star=0;
%     for l=1:n
%         T=ele(star(l),2:4);
%         for w=1:3
%             if T(w)~=r
%                 if l==1 && (w==1 || w==2)
%                     q=q+1;
%                     poly_star(q)=T(w);
%                 else
%                     found_dup_nd=0;
%                     for x=1:q
%                         if T(w)==poly_star(x)
%                             found_dup_nd=1;
%                         end
%                     end
%                     if found_dup_nd
%                         ;
%                     else
%                         q=q+1;
%                         poly_star(q)=T(w);
%                     end
%                 end
%             end
%         end
%     end
%     P{3,1}=q; % The number of saterlite nodes in the current star structure
%     P{4,1}=poly_star; % The vector of saterlite node order numbers in the current star structure
% 
%     P{5,1}=0; % The centroid of the polygon constructed by the outer boundaries of the star structure
% 
%     P{6,1}=0; % The biggest AR among all star triangles
% 
%     P{7,1}=0; % the biggest Skewness among all star triangles
%     
%     Star{r}=P;
% end
% %% Calculate the Aspect Ratio, angles and skewness of each triangle
% Theta_e=60; % reference angle for triangle
% Tri_angle=zeros(M,5);
% for r=1:M
%     T=ele(r,:);
%     nd_a=T(1,2);
%     nd_b=T(1,3);
%     nd_c=T(1,4);
%     C_a=node(nd_a,2:3)';
%     C_b=node(nd_b,2:3)';
%     C_c=node(nd_c,2:3)';
%     L_a=dis(C_a,C_b);
%     L_b=dis(C_b,C_c);
%     L_c=dis(C_c,C_a);
%     L_max=max(L_a,max(L_b,L_c));
%     L_min=min(L_a,min(L_b,L_c));
%     % Aspect Ratio
%     Tri_angle(r,1)=L_max/L_min;
%     % Angles
%     for k=1:3
%         if k==1
%             u=C_b-C_a;
%             v=C_c-C_a;
%         elseif k==2
%             u=C_c-C_b;
%             v=C_a-C_b;
%         else
%             u=C_a-C_c;
%             v=C_b-C_c;
%         end
%         Tri_angle(r,1+k)=angle(u,v);
%     end
%     if single(Tri_angle(r,2)+Tri_angle(r,3)+Tri_angle(r,4))~=single(180)
%         error('The sum of three angles is not 180 degrees!');
%     end
%     % Skewness
%     Theta_max=max(Tri_angle(r,2),max(Tri_angle(r,3),Tri_angle(r,4)));
%     Theta_min=min(Tri_angle(r,2),min(Tri_angle(r,3),Tri_angle(r,4)));
%     Tri_angle(r,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
% end
% %% Fill the information into the Star cell
% for r=1:N
%     P=Star{r};
%     star=P{2,1};
%     poly_star=P{4,1}; % The vector of saterlite node order numbers in the current star structure
%     poly_center=[0,0];
%     for s=1:P{3,1}
%         poly_center=poly_center+node(poly_star(s),2:3);
%     end
%     poly_center=poly_center/P{3,1};
%     P{5,1}=poly_center; % The centroid of the polygon constructed by the outer boundaries of the star structure
%     AR=zeros(1,P{1,1});
%     for s=1:P{1,1}
%         AR(s)=Tri_angle(star(s),1);
%     end
%     P{6,1}=max(AR); % The biggest AR among all star triangles
% 
%     SK=zeros(1,P{1,1});
%     for s=1:P{1,1}
%         SK(s)=Tri_angle(star(s),5);
%     end
%     P{7,1}=max(SK); % the biggest Skewness among all star triangles
%     
%     Star{r}=P;
% end
% %% Determine the global worst AR and SK values
% AR_max=1.79; % Improvement stop criteria for Aspect Ratio
% SK_max=0.41; % Improvement stop criteria for Skewness
% Ar_max=zeros(N,1);
% Sk_max=zeros(N,1);
% for r=1:N
%     P=Star{r};
%     Ar_max(r)=P{6};
%     Sk_max(r)=P{7};
% end
% Ar_max_global=max(Ar_max);
% Sk_max_global=max(Sk_max);
% WAR=['Before move, Ar_max_global=',num2str(Ar_max_global), ', ', 'Sk_max_global=', num2str(Sk_max_global), '.' ]
% AR_avg_b4_move=norm(Tri_angle(:,1),1)/M
% SK_avg_b4_move=norm(Tri_angle(:,5),1)/M
% %% plot the mesh with all bad triangles marked up
% % figure(2);
% % edge1_x=zeros(M,2);
% % edge2_x=zeros(M,2);
% % edge3_x=zeros(M,2);
% % edge1_y=zeros(M,2);
% % edge2_y=zeros(M,2);
% % edge3_y=zeros(M,2);
% % for r=1:M
% %     nd1=ele(r,2);
% %     nd2=ele(r,3);
% %     nd3=ele(r,4);
% %     edge1_x(r,:)=[node(nd1,2),node(nd2,2)];
% %     edge2_x(r,:)=[node(nd2,2),node(nd3,2)];
% %     edge3_x(r,:)=[node(nd3,2),node(nd1,2)];
% %     edge1_y(r,:)=[node(nd1,3),node(nd2,3)];
% %     edge2_y(r,:)=[node(nd2,3),node(nd3,3)];
% %     edge3_y(r,:)=[node(nd3,3),node(nd1,3)];
% % end
% % for r=1:M
% %     plot(edge1_x(r,:),edge1_y(r,:),'black');
% %     hold on
% %     plot(edge2_x(r,:),edge2_y(r,:),'black');
% %     hold on
% %     plot(edge3_x(r,:),edge3_y(r,:),'black');
% %     hold on
% % end
% % axis equal tight
% % hold on
% % for r=1:M
% %     if Tri_angle(r,1)>=AR_max || Tri_angle(r,5)>=SK_max
% %         plot(edge1_x(r,:),edge1_y(r,:),'red');
% %         hold on
% %         plot(edge2_x(r,:),edge2_y(r,:),'red');
% %         hold on
% %         plot(edge3_x(r,:),edge3_y(r,:),'red');
% %         hold on
% %     end
% % end
% % %%%%%%%%%%%%%%%% 4-Tri structure killer %%%%%%%%%%%%%%%%%%%%
% % WAR=['Before killing 4-Tri structure, Ar_max_global=',num2str(Ar_max_global), ', ', 'Sk_max_global=', num2str(Sk_max_global), '.' ]
% % AR_avg_b4_kill=norm(Tri_angle(:,1),1)/M
% % SK_avg_b4_kill=norm(Tri_angle(:,5),1)/M
% % %% kill all 4-triangle structure by swapping
% % [ele,neigh,Star]=PostTri_4Tri_killer(ele,node,neigh,Star);
% % %% Calculate the Aspect Ratio, angles and skewness of each triangle
% % for r=1:M
% %     T=ele(r,:);
% %     nd_a=T(1,2);
% %     nd_b=T(1,3);
% %     nd_c=T(1,4);
% %     C_a=node(nd_a,2:3)';
% %     C_b=node(nd_b,2:3)';
% %     C_c=node(nd_c,2:3)';
% %     L_a=dis(C_a,C_b);
% %     L_b=dis(C_b,C_c);
% %     L_c=dis(C_c,C_a);
% %     L_max=max(L_a,max(L_b,L_c));
% %     L_min=min(L_a,min(L_b,L_c));
% %     % Aspect Ratio
% %     Tri_angle(r,1)=L_max/L_min;
% %     % Angles
% %     for k=1:3
% %         if k==1
% %             u=C_b-C_a;
% %             v=C_c-C_a;
% %         elseif k==2
% %             u=C_c-C_b;
% %             v=C_a-C_b;
% %         else
% %             u=C_a-C_c;
% %             v=C_b-C_c;
% %         end
% %         Tri_angle(r,1+k)=angle(u,v);
% %     end
% %     if single(Tri_angle(r,2)+Tri_angle(r,3)+Tri_angle(r,4))~=single(180)
% %         error('The sum of three angles is not 180 degrees!');
% %     end
% %     % Skewness
% %     Theta_max=max(Tri_angle(r,2),max(Tri_angle(r,3),Tri_angle(r,4)));
% %     Theta_min=min(Tri_angle(r,2),min(Tri_angle(r,3),Tri_angle(r,4)));
% %     Tri_angle(r,5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
% % end
% % %% Fill the information into the Star cell
% % for r=1:N
% %     P=Star{r};
% %     star=P{2,1};
% %     poly_star=P{4,1}; % The vector of saterlite node order numbers in the current star structure
% %     poly_center=[0,0];
% %     for s=1:P{3,1}
% %         poly_center=poly_center+node(poly_star(s),2:3);
% %     end
% %     poly_center=poly_center/P{3,1};
% %     P{5,1}=poly_center; % The centroid of the polygon constructed by the outer boundaries of the star structure
% %     AR=zeros(1,P{1,1});
% %     for s=1:P{1,1}
% %         AR(s)=Tri_angle(star(s),1);
% %     end
% %     P{6,1}=max(AR); % The biggest AR among all star triangles
% % 
% %     SK=zeros(1,P{1,1});
% %     for s=1:P{1,1}
% %         SK(s)=Tri_angle(star(s),5);
% %     end
% %     P{7,1}=max(SK); % the biggest Skewness among all star triangles
% %     
% %     Star{r}=P;
% % end
% % %% Determine the global worst AR and SK values
% % Ar_max=zeros(N,1);
% % Sk_max=zeros(N,1);
% % for r=1:N
% %     P=Star{r};
% %     Ar_max(r)=P{6};
% %     Sk_max(r)=P{7};
% % end
% % Ar_max_global=max(Ar_max);
% % Sk_max_global=max(Sk_max);
% % WAR=['After killing 4-Tri structure before node movement, Ar_max_global=',num2str(Ar_max_global), ', ', 'Sk_max_global=', num2str(Sk_max_global), '.' ]
% % AR_avg_after_kill_b4_move=norm(Tri_angle(:,1),1)/M
% % SK_avg_after_kill_b4_move=norm(Tri_angle(:,5),1)/M
% % %%%%%%%%%%%%%%%% 4-Tri structure killer %%%%%%%%%%%%%%%%%%%%
% TRI_M=zeros(M,1);
% c_loop=0;
% bad_tri_counter=0;
% for r=1:M
%     if Tri_angle(r,1)>=AR_max || Tri_angle(r,5)>=SK_max
%         bad_tri_counter=bad_tri_counter+1;
%         bad_tri(bad_tri_counter)=r;
%     end
% end
% % while Ar_max_global>AR_max || Sk_max_global>SK_max
% for r=1:bad_tri_counter
% %     c_loop=c_loop+1
% %     worst_tri_found=0;
% %     for r=1:M
% %         if mod(c_loop,2)==0
% %             if single(Tri_angle(r,1))==single(Ar_max_global)
% %                 worst_tri_found=1;
% %                 break;
% %             end
% %         else
% %             if single(Tri_angle(r,5))==single(Sk_max_global)
% %                 worst_tri_found=1;
% %                 break;
% %             end
% %         end
% %     end
% %     if worst_tri_found==0
% %         error('The triangle with worst quality is not found!');
% %     end
% %     tri_move=r
% %     TRI_M(r)=TRI_M(r)+1;
% %     if TRI_M(r)>1
% %         WAR=['Triangle ',num2str(r), ' has been found for 10 times, ', ' the algorithm failed.' ]
% %         break;
% %     end
%     tri_move=bad_tri(r);
%     %% determing all vertices in the found triangle that can be moved
%     nd_can_move=0;
%     j=0;
%     for i=1:3
%         if node(ele(tri_move,1+i),4)==0
%             j=j+1;
%             nd_can_move(j)=ele(tri_move,1+i);
%         end
%     end
%     %% Move the node
%     num_nd_can_move=length(nd_can_move);
%     if num_nd_can_move==0
%         error('All nodes of found triangle are all on boundary! Use Triangle again to have a different mesh!');
%     elseif num_nd_can_move==1
%         ;
%     elseif num_nd_can_move==2
%         ;
%     elseif num_nd_can_move==3
%         max_angle=max(Tri_angle(tri_move,2:4));
%         min_angle=min(Tri_angle(tri_move,2:4));
%         nd_min_angle=0; % The node with min angle in the found triangle
%         nd_max_angle=0; % The node with max angle in the found triangle
%         nd_med_angle=0; % The node with medium angle in the found triangle
%         for i=1:3
%             if Tri_angle(tri_move,i+1)==min_angle
%                 nd_min_angle=ele(tri_move,i+1);
%             elseif Tri_angle(tri_move,i+1)==max_angle
%                 nd_max_angle=ele(tri_move,i+1);
%             else
%                 nd_med_angle=ele(tri_move,i+1);
%             end
%         end
%         if nd_med_angle==0 % Special case that two angles are the same
%             for i=1:3
%                 if ele(tri_move,i+1)~=nd_min_angle && ele(tri_move,i+1)~=nd_max_angle
%                     nd_med_angle=ele(tri_move,i+1);
%                 end
%             end
%         end
%         if nd_min_angle==0 || nd_max_angle==0 || nd_med_angle==0
%             error('The nodes with max, min and medium angle in the found triangle are not found!');
%         end
%         % Determine the moving vector and step size for each node to be moved,
%         % algorithm depends on whether the node has max,min or medium angle
%         
%         % min
%         dis_move_min_angle=dis(node(nd_min_angle,2:3)',node(nd_med_angle,2:3)');
%         vec_move_min_angle=(node(nd_med_angle,2:3)'-node(nd_min_angle,2:3)')/dis_move_min_angle;
%         step_move_min_angle=dis_move_min_angle/20;
%         % max
%         dis_move_max_angle=dis(node(nd_max_angle,2:3)',node(nd_med_angle,2:3)');
%         vec_move_max_angle=(node(nd_max_angle,2:3)'-node(nd_med_angle,2:3)')/dis_move_max_angle;
%         step_move_max_angle=dis_move_max_angle/20;
%         % med
%         dis_move_med_angle=dis(node(nd_max_angle,2:3)',node(nd_min_angle,2:3)');
%         vec_move_med_angle=(node(nd_min_angle,2:3)'-node(nd_max_angle,2:3)')/dis_move_med_angle;
%         step_move_med_angle=dis_move_med_angle/40;
%         
%         % combining
%         nd_move=[nd_min_angle,nd_max_angle,nd_med_angle]; % The sequence is always kept as min,max,med.
%         vec_move=[vec_move_min_angle,vec_move_max_angle,vec_move_med_angle];
%         step_move=[step_move_min_angle,step_move_max_angle,step_move_med_angle];
%         
%         
%         % Calculate the averge AR and SK value for the star triangles of each
%         % node
%         Ar_avg_old=zeros(1,3);
%         Sk_avg_old=zeros(1,3);
%         for i=1:3
%             P=Star{nd_move(i)};
%             star=P{2};
%             for r=1:P{1}
%                 Ar_avg_old(i)=Ar_avg_old(i)+Tri_angle(star(r),1);
%                 Sk_avg_old(i)=Sk_avg_old(i)+Tri_angle(star(r),5);
%             end
%             Ar_avg_old(i)=Ar_avg_old(i)/P{1};
%             Sk_avg_old(i)=Sk_avg_old(i)/P{1};
%         end
%         
%         MOVE=[1,1,1]; % Flag for each node to determine whether to move. 1---move; 0---not move
%         while norm(MOVE,1)>0 % At least one node can still be moved
%             for i=1:3
%                 node_temp=node;
%                 Tri_angle_temp=Tri_angle;
%                 move_end=node_temp(nd_move(i),2:3)+step_move(i)*vec_move(:,i)';
%                 node_temp(nd_move(i),2:3)=move_end;
%                 P=Star{nd_move(i)};
%                 star=P{2};
%                 for r=1:P{1}
%                     T=ele(star(r),:);
%                     nd_a=T(1,2);
%                     nd_b=T(1,3);
%                     nd_c=T(1,4);
%                     C_a=node_temp(nd_a,2:3)';
%                     C_b=node_temp(nd_b,2:3)';
%                     C_c=node_temp(nd_c,2:3)';
%                     L_a=dis(C_a,C_b);
%                     L_b=dis(C_b,C_c);
%                     L_c=dis(C_c,C_a);
%                     L_max=max(L_a,max(L_b,L_c));
%                     L_min=min(L_a,min(L_b,L_c));
%                     % Aspect Ratio
%                     Tri_angle_temp(star(r),1)=L_max/L_min;
%                     % Angles
%                     for k=1:3
%                         if k==1
%                             u=C_b-C_a;
%                             v=C_c-C_a;
%                         elseif k==2
%                             u=C_c-C_b;
%                             v=C_a-C_b;
%                         else
%                             u=C_a-C_c;
%                             v=C_b-C_c;
%                         end
%                         Tri_angle_temp(star(r),1+k)=angle(u,v);
%                     end
%                     if single(Tri_angle_temp(star(r),2)+Tri_angle_temp(star(r),3)+Tri_angle_temp(star(r),4))~=single(180)
%                         error('The sum of three angles is not 180 degrees!');
%                     end
%                     % Skewness
%                     Theta_max=max(Tri_angle_temp(star(r),2),max(Tri_angle_temp(star(r),3),Tri_angle_temp(star(r),4)));
%                     Theta_min=min(Tri_angle_temp(star(r),2),min(Tri_angle_temp(star(r),3),Tri_angle_temp(star(r),4)));
%                     Tri_angle_temp(star(r),5)=max((Theta_max-Theta_e)/(180-Theta_e),(Theta_e-Theta_min)/Theta_e);
%                 end
%                 
%                 Ar_avg_new=zeros(1,3);
%                 Sk_avg_new=zeros(1,3);
%                 for j=1:3
%                     P=Star{nd_move(j)};
%                     star=P{2};
%                     for r=1:P{1}
%                         Ar_avg_new(j)=Ar_avg_new(j)+Tri_angle_temp(star(r),1);
%                         Sk_avg_new(j)=Sk_avg_new(j)+Tri_angle_temp(star(r),5);
%                     end
%                     Ar_avg_new(j)=Ar_avg_new(j)/P{1};
%                     Sk_avg_new(j)=Sk_avg_new(j)/P{1};
%                 end
%                 SIGN=sign(sign(Ar_avg_old-Ar_avg_new)+sign(Sk_avg_old-Sk_avg_new)); % Determine whether averaged quality is improved for each star-triangles
%                 % 1---Improved;0---One of AR and SK improved, the other
%                 % disimproved;-1---disimproved
%                 if SIGN(i)==-1
%                     MOVE(i)=0; % Don't move current node
%                 elseif SIGN(i)==0
%                     if (sum(SIGN)-SIGN(i))<1
%                         MOVE(i)=0; % Don't move current node
%                     else
%                         MOVE(i)=0; % Can move current node
%                     end
%                 elseif SIGN(i)==1
%                     if (sum(SIGN)-SIGN(i))<=1
%                         MOVE(i)=0; % Can move current node
%                     else
%                         MOVE(i)=1; % Can move current node
%                         node=node_temp;
%                         Tri_angle=Tri_angle_temp;
%                         Ar_avg_old=Ar_avg_new;
%                         Sk_avg_old=Sk_avg_new;
%                     end
%                 else
%                     error('SIGN mush be -1, 0 or 1!');
%                 end
%             end
%         end
%     else
%         error('The total number of vertices that can be moved cannot be more than three!');
%     end
%     % Dtermine the new max AR and SK values globaly
%     Ar=zeros(M,1);
%     Sk=zeros(M,1);
%     for r=1:M
%         Ar(r)=Tri_angle(r,1);
%         Sk(r)=Tri_angle(r,5);
%     end
%     Ar_max_global=max(Ar)
%     Sk_max_global=max(Sk)
% end
% %%%%%%% Plan C ends %%%%%%%%%